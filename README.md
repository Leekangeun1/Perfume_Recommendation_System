# App Download Link
https://drive.google.com/file/d/1mEs5q6IhmaItt2oLWxI1aAiBMYVjgs1H/view?usp=sharing

--------------------------------

## Perfume Recommendation System

This project is a starting point for a Flutter application.

A few resources to get you started if this is your first Flutter project:

- [Lab: Write your first Flutter app](https://docs.flutter.dev/get-started/codelab)
- [Cookbook: Useful Flutter samples](https://docs.flutter.dev/cookbook)

For help getting started with Flutter development, view the
[online documentation](https://docs.flutter.dev/), which offers tutorials,
samples, guidance on mobile development, and a full API reference.

----------------------------

## Presentation Scripts

(제목)
 안녕하십니까, 이번 프로젝트로 향수 추천 시스템을 만든 이강은이라고 합니다. 

2. (팀 멤버)
 팀 멤버는 저 혼자이고요, 혼자 진행하는 프로젝트이다보니, 역할 분담은 따로 없이 data collection, data storing, ui design, implementation을 혼자 진행하였습니다. 

3. (주제는 향수)
 향수는 우리 삶에서 매우 중요한 역할을 합니다. 우리의 매력이나 정체성을 표현하고 나라는 사람의 identity를 확립하는 데에 있어 향수는 매우 큰 역할을 합니다. 인간의 후각이 오감 중에서 가장 민감한 감각이라는 말이 있듯이, 대인 관계에 있어서도 사람에게서 느껴지는 향기는 그 사람의 첫인상을 결정하는 데에 굉장히 큰 역할을 합니다. 그래서 일반적으로 향수에 관심을 가지고 계신 분들이 많을 텐데요, 이러한 상황에서 문제점들이 몇 가지 발생합니다. 향수를 사러 매장에 가보게 되면, 아무거나 살 수는 없으니 여러 향수들의 향을 맡아보고 테스트해본 뒤에 구매하게 되는데요, 문제는 이런 향수들이 너무나 많고 다양하다는 것입니다. 브랜드별로 향수 모델의 개수는 수백 개에서 수천 개까지 매우 많습니다. 이 많은 걸 다 시향해본 뒤에 구매하는 건 불가능할 겁니다. 또한 더 큰 문제점은, 우리의 코는 자극에 대해서 쉽게 피로를 느낀다는 점입니다. 후각신경은 민감한 만큼 쉽게 피로를 느껴서, 향을 몇 번 맡아보게 되면, 처음과는 달리 그 향이 그 향 같고, 어떤 게 더 좋은 향인지 구분하는 게 매우 힘들어집니다. 그래서 저는 향수를 추천해주는 시스템을 만들어 보기로 하였습니다. 

4. (data collection: kaggle)
 향수를 효과적으로 추천해주기 위해서는, 정형화된 향수의 리스트들이 필요합니다. 그래서 저는 Kaggle이라는 사이트로부터 open data set을 얻어왔습니다. 향수들의 모델과 브랜드, 그리고 가지고 있는 향들을 정리해 둔 data set이었습니다. 하지만 이 데이터들만 가지고는 향수를 구체화하여 정리하기 어렵다고 생각했습니다. 이를테면 향수가 가진 향들을 더 구조화해서 표현하고, 어울리는 계절이나 분위기 등도 있으면 좋겠다고 생각했습니다. 

5. (data collection: basenotes)
 그래서 방금 말씀드렸던 data set과 더불어 data collection을 한 번 더 진행하기로 했습니다. 이 향수 정보 사이트에서는 향수 모델을 검색하면 그 향수에 대한 정보를 보여줍니다. 이 사이트에서는 향수의 이름, 브랜드, 출시 일자.......
(Enter) - 향수 세부적인 모습
그리고 향들의 배합을 보여줍니다. 이를테면 지금 보여드리는 향수는 샤넬에서 2010년에 출시한 ‘블루드 샤넬 오드 뚜왈렛’이라는 향수입니다. 이 향수는 시트러스, 페퍼민트, 자스민 등등의 향을 포함하고 있습니다. 그래서 이 사이트에 대해서 웹 크롤링을 진행했습니다. 이전에 Kaggle에서 가져온 향수 이름을 검색해서 나온 결과 사이트에서 데이터를 추출하고, 구조를 다듬었습니다.
(Enter) - json 형태 모습
그래서 지금 보시는 바와 같이 향수 하나에 대해서 데이터가 이렇게 정리된 모습을 보실 수 있습니다. json format에 맞게 향수 데이터들을 정리했고요, 제일 위쪽부터 primary key입니다. 향수들을 구분할 ID들이고요, 그 밑에 fields의 하위 컬렉션으로 이름, 출시일자, 썸네일, 성별, 노트들, 어울리는 계절, 구매 가능 여부, 브랜드, 카테고리, 가격 순으로 정리해 두었습니다. 노트 부분을 보시면 top, heart, base로 나뉘어져 있는 걸 보실 수 있는데요, 간단하게만 설명해드리자면, top 노트는 향수를 뿌린 직후부터 알코올이 증발하기까지 약 10분 동안 맡을 수 있는 향입니다. heart 노트는 그 이후부터 약 3시간동안 맡을 수 있는 핵심적인 향이고요, base 노트는 향수를 뿌린 후 3시간 뒤부터 은은하게 맡을 수 있는 향입니다. 이렇게 3가지 향을 구획별로 정리해 두었습니다. 

6. (data collection: firebase)
 그래서 결과적으로 모은 향수 모델이 약 40000개 정도 됩니다. 향수들의 모델뿐만 아니라 데이터를 원활하게 관리하기 위해 향수들의 브랜드나 노트, 카테고리, 시즌 같은 데이터들도 따로 정의해서 저장해 두었습니다. 이렇게 해서 모든 데이터들을 모아서 json 형태로 저장했더니 약 140만줄 정도의 분량이 나왔습니다. 그리고 이 많고 많은 데이터들을 넣어두고 관리할 곳이 필요했는데요, 그 역할을 한 database server가 firebase입니다. 그래서 firebase에서 인식할 수 있는 형태로 json 형태를 다듬어준 뒤에

7. (data collection: firebase - 그림)
이렇게 firebase에 data set을 등록해 주었습니다. 
(Enter) - firebase2
그래서 아까 말씀드렸던 perfume의 정보가 모두 알맞게 들어간 모습을 보실 수 있습니다. 

8. (Recommendation Method)
 그럼 이 프로젝트의 추천 방법을 말씀드리겠습니다. 향수의 데이터가 40000개로 매우 많고, 리뷰는 그에 반해 매우 적은 편이어서, contents based filtering 방법을 사용하기로 했습니다. 사용자가 한 향수를 선택하면, 그 향수와 관련있는 다른 향수 모델들을 함께 추천해주는 방식입니다. 

9. (Cosine Similarity)
 그래서 이 향수를 추천해주는 알고리즘으로는 cosine similarity 방식을 사용하였습니다. 오른쪽에 보시는 모습이 이를 코드로 구현한 내용입니다. 이를 조금 더 자세히 살펴보도록 하겠습니다. 
(Enter) - Caculation Equations
두 개의 향수 모델 1, 2가 있다고 생각해보겠습니다. 모델 1은 오직 3번째 카테고리만 가지고 있고, 모델 2는 2번째와 3번째 카테고리를 동시에 가지고 있습니다. 포함 되었음과 포함되지 않았음을 표현하기 위해서 binary하게 0과 1만 사용하였습니다. 그래서 모델 1과 2의 길이는 피타고라스로 구했고요, 두 모델을 여기 예시에서는 5차원 벡터라고 가정하고 좌표처럼 내적값을 구했습니다. 이렇게 해서 내적의 정의를 이용해서 cosine 값을 구했고, 최종적으로 산출된 값이 cosine similarity가 됩니다. 

10. (Model1 and Model2)
 방금은 카테고리로만 예시를 들었지만, 두 모델을 비교할 척도는 카테고리 뿐만이 아닐 겁니다. 예를 들면 노트가 있을 겁니다. 이 노트의 경우에는 연관성을 계산하기가 어려웠는데요, 노트가 3가지 계층으로 나뉘어져 있는데, 같은 노트가 같은 계층에 대응하는 경우도 있었고, 다른 계층으로 대응하는 경우도 있었습니다. 그래서 직접 대응하는 경우는 direct hit, 간접적으로 대응하는 경우는 indirect hit으로 구분해서 계산했습니다. 두 hit의 가중치는 서로 다르게 설정해서 direct hit일 때 더 많은 점수를 얻게끔 하였습니다. 

11. Season:4
 그래서 두 향수 간에 비교하게 되는 척도들을 살펴보게 되면, 첫째로 season이 있습니다. season은 4가지로 분류되어 있기 때문에, 점수를 얻게 되는 기댓값이 상대적으로 크게 설정됩니다. 
(Enter) - category
그리고 category가 있는데, 12개의 category가 있기 때문에 기댓값이 아까보다는 상대적으로 낮습니다. 
(enter) - note
그리고 마지막으로 향의 성분을 나타내는 노트는 총 973가지가 있습니다. 그래서 점수의 기댓값이 매우 낮아집니다. 이 노트는 아까 말씀드렸다시피 
(enter) - direct, indirect
direct hit와 indirect hit가 있기 때문에
(enter) - 코드그림
두 가중치에 차이를 두어서 오른쪽의 그림과 같이 가중치를 정의하여 넣어주었습니다. 

12. Weights
기댓값의 비율에 맞춰서 season과 category는 그 경우의 수만큼 곱해주었고, note에 대해서는 여러 테스트를 거친 결과 가장 적절하다고 판단되는 가중치로 각각 30과 15를 넣어주었습니다. note의 가중치가 너무 크게 되면, season과 category는 무시되게 되고, 너무 작으면 note가 무시되어, 가장 합리적으로 결과를 도출하게끔 가중치를 보시는 바와 같이 설정해 두었습니다.

13. AP@K
다음은 evaluation입니다. 추천 시스템의 평가는 mean average precision @K를 이용해서 만들었고요, 오른쪽에 보시는 코드는 Mean average Precision을 만들기 전 과정인 Average Precision 부분입니다. Mean Average Precision은, 수많은 사용자들이 Average Precision을 평가한 뒤에, 그 평균을 내는 것이기 때문에, 우선 Average Precision을 계산해서 등록하는 코드를 넣어줬습니다.
(enter)
Average precision을 계산하는 방법은 위에 보시는 식을 보시면 됩니다. 어플리케이션을 실행하면, 추천 리스트를 1등부터 10등까지 나타내서 보여드리게 될 겁니다. 사용자는 해당 추천 리스트가 잘 추천 되었는지 그 결과의 만족도를 위의 식을 이용해서 보여주게 될 것입니다. 1등부터 10등까지의 리스트를 보게 된다면 10등보다는 1등의 정확성이 더 중요하지 않습니까? 그래서 1등의 가중치가 제일 높고, 10등의 가중치가 제일 낮게 되는 방법인 이 AP 방법을 사용하였습니다. 한가지 예시로는 1등부터 4등까지만 간략하게 보여드리겠습니다. 사용자가 이 앱을 평가할 때, 1등과 3등은 만족스럽지만 2등과 4등은 만족스럽지 못했다고 하면, 보시는 테이블처럼 평가표가 정리됩니다. Precision i와 relation i의 곱은 보시는 바와 같이 나타납니다. (왼쪽에서부터 1개, 2개, 3개, 4개 순으로 설명한다.)
----------------------------------------------------------------------
m = 사용자가 좋아한 아이템 개수. 7개 선택했으면 7.
k = precision의 개수. 여기선 precision을 총 4번 했으니까 precision은 4.
P(i) = 1~i번째 인덱스 중에서 사용자가 좋아한 아이템의 비율
rel(i) = 해당 인덱스를 사용자가 좋아했는지 여부. 1과 0으로 이루어짐.
----------------------------------------------------------------------
14. MAP@K
아까 말씀드렸던 방식으로 계산되었던 사용자들의 Average precision은 데이터베이스에 추가적으로 등록됩니다. MAP@K를 계산하기 위해서는, 저장된 DB에 접근해서 누적된 Average Precision을 다 더해서 평균을 구해줍니다. 이러한 방식으로 MAP@K를 구하는 알고리즘을 구현하였습니다.

15. Implementaion
이제 프로젝트를 구현한 내용에 대해서 말씀드린 뒤에, 데모까지 이어서 진행하겠습니다. 처음에 말씀드렸던 kaggle과 basenote website crawling을 이용해서 정규화된 데이터를 얻었고, 이를 json 형태로 정리하였습니다. 이 DB는 firebase에 저장하였습니다. 그리고 이 서버와 연동된 플러터를 이용해서 안드로이드 앱 개발을 진행했습니다. Recommendation과 Evaluation은 이 flutter 상에서 구현되어 있습니다. 그렇게 해서 안드로이드 APK 파일을 생성했고, 그 시연 영상을 이제 확인해보겠습니다.

16. Demo
데모 영상을 보시기 전에, 소스코드는 깃헙에 public으로 올려놨고, 아래 있는 링크는 APK를 다운받아서 사용해보실 수 있는 다운로드 링크입니다. 깃헙에 링크를 올려놨으니, 깃헙에서 다운받으실 수도 있겠습니다. 그럼 데모 영상을 보여드리겠습니다.

17. Lean Canvas
(제일 왼쪽) problem
고객들이 본인이 좋아하는 향수를 효율적으로 고르기 힘들다라는 문제점이 있었고, 현재로서는 이를 해결하는 방법은 그저 판매자가 주관적으로 추천해준 향수들을 고르거나, 직접 다 맡아보는 수밖에 없습니다.
(제일 오른쪽) customer
그래서 이 프로젝트는 이러한 소비자들이 될 것입니다. 20대부터 50대, 혹은 그 이상까지 전연령이 이 프로젝트의 대상이 됩니다.
(가운데) value
그래서 이러한 소비자들에게 제안하는 이 프로젝트의 가치는, 더이상 향수를 고르기 위해 후각을 혹사시키지 않아도 된다는 점입니다. 
(두번째 위) solution
이 추천 시스템은 고객이 좋아할만한 향수를 충분히 제공해줄 수 있을 것입니다.
(두번째 아래) key matrics
이 향수는 모든 고객, 어떤 고객에게도 적용될 수 있는 서비스이고, 시중에 이와 같은 서비스를 제공해주는 서비스는 없기 때문에 충분히 가치있는 서비스라고 생각합니다. 

18. Schedule
프로젝트를 진행하면서 11월동안은 구체적인 계획을 수립하고 데이터를 모아서 구조화하고 분류하는 데에 주력했습니다. 그리고 12월달부터 프론트엔드에서의 개발을 시작했는데요, 간단한 UI 위에서 주요 기능을 먼저 구현한 뒤에, 남은 기간동안 알고리즘을 개선시키고 UI를 구체화하여 디자인했습니다. 그렇게 해서 이와 같은 프로젝트를 완성할 수 있었습니다.

19. End
발표 들어주셔서 감사합니당
